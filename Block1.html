<!DOCTYPE doctype PUBLIC "-//w3c//dtd html 4.0 transitional//en">
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta name="GENERATOR" content="Mozilla/4.7 [en] (X11; I; Linux
      2.4.16 ppc) [Netscape]">
    <meta name="Author" content="Ronald Burkey">
    <title>Virtual AGC Assembly-Language Manual</title>
    <meta name="author" content="Ronald S. Burkey">
    <script type="text/javascript" src="Header.js"></script>
  </head>
  <body style="background-image: url(gray3.jpg);">
    <script type="text/javascript">document.write(headerTemplate.replace("@TITLE@","The Block I AGC").replace("@SUBTITLE@","in all its Aspects"))</script>
    <br>
    <br>
    <div align="center"><big><big><i><b>This page is currently under
              construction</b></i></big></big><br>
    </div>
    <br>
    <h2>Contents</h2>
    <ul>
      <li><a href="#Blocks_for_All_Occasions">Blocks for All Occasions</a></li>
      <li><a href="#Intro">Introduction</a></li>
      <li><a href="#Available_Documentation">Available Documentation</a></li>
      <li><a href="#Block_1_Computer_System">Block 1 Computer System</a></li>
      <ul>
        <li><a href="#Computer">Computer</a></li>
        <li><a href="#DSKY">DSKY</a></li>
        <li><a href="#Other_Peripherals">Other Peripherals</a><br>
        </li>
      </ul>
      <li><a href="#Hardware_Architecture">Computer Hardware
          Architecture</a></li>
      <ul>
        <li><a
href="file:///home/rburkey/git/virtualagc-web/Block1.html#CPU_Architecture_Registers">CPU














            Architecture (Registers)</a></li>
        <li><a
            href="file:///home/rburkey/git/virtualagc-web/Block1.html#Memory_Map">Memory














            Map</a></li>
        <li><a
href="file:///home/rburkey/git/virtualagc-web/Block1.html#Interrupt_Processing">Interrupt














            Processing</a></li>
        <li><a
            href="file:///home/rburkey/git/virtualagc-web/Block1.html#io_channels">I/O














            Channels</a></li>
        <li><a
href="file:///home/rburkey/git/virtualagc-web/Block1.html#UnprogrammedSequences">Unprogrammed














            Sequences</a></li>
      </ul>
      <li><a href="#Software">Software</a><br>
      </li>
      <ul>
        <li><a href="#The_Interpreter_vs._the_CPU">The Interpreter vs.
            the CPU's Basic Instruction Set</a><br>
        </li>
        <li><a href="#Formatting">Source-Code Formatting Information</a></li>
        <li><a href="#Data_Representation">Data Representation</a></li>
        <li><a href="#Instruction_Representation">Instruction
            Representation</a></li>
        <li><a href="#AGC4_Instruction_Set">AGC4_Instruction_Set</a></li>
        <li><a href="#Pseudo-Operations">Pseudo-Operations</a></li>
        <li><a href="#Interpreter_Instruction_Set">Interpreter
            Instruction Set</a></li>
        <li><a href="#Instruction-Set_Summary_Tables">Instruction-Set
            Summary Tables</a></li>
      </ul>
      <li><a href="#Pulse_Sequences">Pulse Sequences</a></li>
      <li><a href="#Available_Block_1_AGC_Software">Available Block 1
          AGC Software</a></li>
      <li><a href="#Available_Supporting_Software">Available Supporting
          Software</a></li>
      <ul>
        <li><a
href="file:///home/rburkey/git/virtualagc-web/Block1.html#Virtual_AGCs_Assembler_yaYUL">Virtual














            AGC's Assembler (yaYUL)</a></li>
        <li><a href="#CPU_Simulators">CPU Simulators</a></li>
        <ul>
          <li><a href="#Comparison">Comparison</a><br>
          </li>
        </ul>
        <ul>
          <li><a href="#John_Pultoraks_Assembler_and_Simulator">John
              Pultorak's Assembler and Simulator</a><br>
          </li>
          <li><a href="#Virtual_AGCs_CPU_Simulator_yaAGCb1">Virtual
              AGC's CPU Simulator (yaAGCb1)</a><br>
          </li>
        </ul>
        <li><a href="#Virtual_AGCs_DSKY_Simulator_yaDSKYb1">Virtual
            AGC's DSKY Simulator (yaDSKYb1)</a><br>
        </li>
      </ul>
    </ul>
    <hr style="width: 100%; height: 2px;">
    <h2><a name="Blocks_for_All_Occasions"></a>Blocks for All Occasions</h2>
    <p>The design of the AGC went through several stages, which for the
      sake of this discussion we'll call "blocks".&nbsp; However, the
      different block designs, while similar in many ways, were quite
      different in others.&nbsp; Rather than try to cover all of them on
      this one page, the different blocks are covered in separate pages:<br>
    </p>
    <ul>
      <li><a href="http://www.ibiblio.org/apollo/NARA-SW/E-1077.pdf">"Block


















          0"</a> — Earliest preliminary design of the AGC for which I
        have any documentation, not used in any missions, and with no
        known existing code.&nbsp; There's a single document (that I
        know of) describing it, so the link is simply to that document,
        rather than to a separate page.</li>
      <li>"Block 1" — Used for the earlier designs of the Command
        Module, which were also referred to a Block 1 spacecraft.&nbsp;
        Used for the unmanned AS-202 ("Apollo 3"), Apollo 4 and Apollo 6
        unmanned missions.&nbsp; There was no such thing as a Block 1
        Lunar Module.<br>
      </li>
      <li><a href="assembly_language_manual.html">"Block 2"</a> — Used
        for the later designs of the Command Module, which were also
        referred to a Block 2 spacecraft.&nbsp; Used for the (unmanned)
        Apollo 5 mission's Lunar Module, and for all manned missions.</li>
      <li><a href="BlockIII.html">"Block 3"</a> — There was no such
        thing in the Apollo program, but Hugh Blair-Smith has given us
        some ideas about what it might have looked like if there were.</li>
    </ul>
    <p>However, <i>this</i> page confines itself just to the Block 1
      design.<br>
    </p>
    <hr style="width: 100%; height: 2px;">
    <h2><a name="Intro"></a>Introduction</h2>
    TBD<br>
    <br>
    <hr style="width: 100%; height: 2px;">
    <h2><a name="Available_Documentation"></a>Available Documentation<br>
    </h2>
    Now, descriptive material about the Block 1 AGC is not as abundant
    as for the Block 2.&nbsp; However, the following are available, and
    are the materials on which I've based the descriptive material on
    this page:<br>
    <ol>
      <li><a href="http://www.ibiblio.org/apollo/hrst/archive/1008.pdf"
          title="Click to view document" target="_blank">R-393:&nbsp;
          Logical Description for the Apollo Guidance Computer (AGC 4)</a>,
        by Albert Hopkins, Ramon Alonso, and Hugh Blair-Smith, July
        1966.</li>
      <li><a href="http://www.ibiblio.org/apollo/hrst/archive/1721.pdf"
          title="Click to view document" target="_blank">R-467:&nbsp;
          The Compleat Sunrise being a description of Program Sunrise
          (Sunrise 33 - NASA DWG# 1021102)</a>, by R. Battin, R. Crisp,
        A. Green, T. J. Lawton, C. A. Muntz, J. Rocchio, and E. Smally,
        September 1964.</li>
      <li>John Pultorak's <a
          href="Pultorak.html#AssemblerSimulatorSourceCode"> Block 1
          simulator source code</a>.</li>
      <li>Solarium 055 <a
href="http://www.ibiblio.org/apollo/ScansForConversion/Solarium055/0001-P1130108.jpg">assembly</a>
        listing, December 4, 1966.</li>
      <li>Personal communications by Hugh Blair-Smith.</li>
      <li>Hugh Blair-Smith's book, <i>Left Brains for the Right Stuff</i>,
        or as he refers to it, <i>LB4TRS</i>.</li>
    </ol>
    <p>Of these, Instrumentation Labs document R-393 is the principle
      documentation of the Block 1 computer system, but it is important
      to recognize that its descriptions are not entirely
      accurate.&nbsp; By this I mean not merely that it contains
      mistakes — as, indeed, any documentation of a sufficiently-complex
      system will — but that the design of the system was extended after
      document R-393 was written.&nbsp; It's my intention to correct
      those deficiencies here, to the extent that I am able to do so.<br>
    </p>
    <p>The most-glaring discrepancy is the memory map, which R-393
      describes as being 1024 words of read/write memory and 12
      1024-word banks of read-only memory, whereas there were in fact 24
      banks of read-only memory by the time of the Solarium (Apollo 6
      unmanned mission) software mentioned above. <br>
    </p>
    <hr size="2" width="100%">
    <h2><a name="Block_1_Computer_System"></a>Block 1 Computer System</h2>
    <p>TBD<br>
    </p>
    <h3><a name="Computer"></a>Computer</h3>
    <p>TBD<br>
    </p>
    <h3><a name="DSKY"></a>DSKY</h3>
    As in Block 2, the DSKY was the display/keyboard unit with which an
    astronaut could have entered data into the computer and gotten feed
    back from it.&nbsp; Block 1 DSKYs differed from Block 2 DSKYs, and
    even from each other.&nbsp; Recall that the Command Module had two
    DSKYs (even though it had only one AGC), one on the main control
    panel and one on the navigation side-panel.&nbsp; The second DSKY
    was used for entering star or other landmark location
    sightings.&nbsp; In a Block 2 CM, the main and nav DSKYs are
    identical.&nbsp; In a Block 1 CM, on the other hand, the main and
    nav DSKYs were different.<br>
    <br>
    <div style="text-align: center;"><img style="width: 904px; height:
        737px;" alt="Block 1 DSKYs" title="The nav-panel DSKY is on the
        left, and the main-panel DSKY is on the right."
        src="Block1DSKYs.jpg" height="737" width="904"><br>
    </div>
    <br>
    The picture above is a crummy reproduction (mine!) of Plate 23
    (courtesy of Raytheon and Jack Poundstone) in Eldon C. Hall's book,
    <span style="font-style: italic;">Journey to the Moon: The History
      of the Apollo Guidance Computer</span>, which anybody interested
    in this website should immediately run out and purchase.&nbsp; (No,
    I don't derive any personal benefit from you doing so.)&nbsp; The
    photo shows Raytheon's first production DSKYs.&nbsp; On the left is
    the nav-panel DSKY, while on the right is the main-panel
    DSKY.&nbsp;&nbsp; (Actually, there is some question as to the use of
    the main-panel DSKY.&nbsp; All Block 1 drawings I can find agree
    about the nav-panel DSKY.&nbsp; But ... some drawings show the
    main-panel DSKY as looking like a Block 2 DSKY while others are
    similar to the photo above.)<br>
    <br>
    Below are some drawings from a set of<big> </big><a
href="http://www.ibiblio.org/apollo/Documents/ApolloTrainingGuidanceAndNavigation_07-65.pdf">Apollo
Guidance















      and Navigation System training slides</a>, July 1965, which are
    perhaps of greater practical utility, if lesser aesthetic
    value.&nbsp; If you click the drawing of the nav-panel DSKY (on the
    left), you can get a larger view in which the text is actually
    legible.<br>
    <br>
    <table style="text-align: left; width: 100%;" border="0"
      cellpadding="2" cellspacing="2">
      <tbody>
        <tr>
          <td style="text-align: center;"><a
              href="Block1DSKY-drawing2.png"><img alt=""
                src="Block1DSKY-drawing2-small.png" style="border: 2px
                solid ; width: 237px; height: 839px;" height="839"
                border="0" width="237"></a></td>
          <td style="text-align: center;"><img style="width: 587px;
              height: 572px;" alt="" src="Block1DSKY-drawing.png"
              height="572" width="587"><br>
          </td>
        </tr>
      </tbody>
    </table>
    <br>
    <div style="text-align: center;"><br>
    </div>
    <p>TBD<br>
    </p>
    <p></p>
    <h3><a name="Other_Peripherals"></a>Other Peripherals</h3>
    <p>TBD<br>
    </p>
    <ol>
    </ol>
    <hr style="width: 100%; height: 2px;">
    <h2><a name="Hardware_Architecture"></a>Computer Hardware
      Architecture</h2>
    <h3><a name="CPU_Architecture_Registers"></a>CPU Architecture
      (Registers) <br>
    </h3>
    <p>TBD<br>
    </p>
    <h3><a name="Memory_Map"></a>Memory Map <br>
    </h3>
    The Block 1 AGC memory map is far simpler than that of the Block 2
    AGC.<br>
    <br>
    Memory is divided into 1024 words (15 bits each) of "erasable"
    memory — i.e., memory which can both be read from and written to —
    and 24 banks, each with 1024 words of read-only or "fixed" memory.<br>
    <br>
    Conventionally, AGC programming uses octal notation, as opposed to
    decimal or hexadecimal notation, for most purposes, and I'll do that
    below, but I'll always try to prefix an extra 0 to the front of an
    octal number to make it easy to recognize as being octal.&nbsp; For
    example, if you see 15, you'll know that it's 15 decimal because
    there's no leading zero, whereas of you see 015, you'll know that
    it's octal (=13 decimal).&nbsp; That's only a convention on this
    page, and in program listings, expect to see everything in octal
    with no leading zeroes.<br>
    <br>
    Memory is laid out as follows:<br>
    <ul>
      <li>Addresses 00000-01777 — erasable memory.</li>
      <li>Addresses 02000-03777 (or theoretically, 01,06000-01,07777) —
        Bank 1 of fixed memory.</li>
      <li>Addresses 04000-05777 (or theoretically, 02,06000-02,07777) —
        Bank 2 of fixed memory.</li>
      <li>Addresses 03,06000-03,07777 — Bank 3 of fixed memory.</li>
      <li>...</li>
      <li>Addresses 14,06000-14,07777 — Bank 14 of fixed memory.</li>
      <li><i>Though logically present as far as software is concerned,
          banks 15, 16, 17, and 20 are not physically present in the
          hardware.</i><br>
      </li>
      <li>Addresses 21,06000-21,07777 —Bank 20 of fixed memory.</li>
      <li>...<br>
      </li>
      <li>Addresses 034,06000-034,07777 — Bank 34 of fixed memory.<br>
      </li>
    </ul>
    Thus, fixed memory locations can always be referred to as<br>
    <blockquote><i>BB,AAAA</i><br>
    </blockquote>
    where <i>BB</i> is an octal bank number from 01 to 034, and AAAA is
    an octal offset into that bank from 06000 to 07777.&nbsp; Only banks
    01 and 02 have the special short addresses 02000 through 05777, and
    they are invariably referred to in that way rather than in the <i>BB,AAAA</i>
    form.<br>
    <h3><a name="Interrupt_Processing"></a>Interrupt Processing <br>
    </h3>
    <p>TBD<br>
    </p>
    <h3><a name="io_channels"></a>I/O Channels</h3>
    TBD<br>
    <h3><a name="UnprogrammedSequences"></a>Unprogrammed Sequences</h3>
    TBD<br>
    <br>
    <p> </p>
    <hr style="width: 100%; height: 2px;">
    <h2><a name="Software"></a>Software</h2>
    <h3><a name="The_Interpreter_vs._the_CPU"></a>The Interpreter vs.
      the CPU's Basic Instruction Set<br>
    </h3>
    As mentioned above, the Block 1 AGC design did not end up being used
    in any moon missions, nor even in any manned missions, but if it <i>had</i>
    been used, the required software could not have been fit into the
    memory provided by the Block 1 unit if simply written in the AGC
    CPU's native assembly language.&nbsp; (Nor even in the Block 2
    computer, <a
      href="assembly_language_manual.html#The_Interpreter_vs._the_CPU">as



















      described here</a>.)&nbsp; Consequently, as with the Block 2
    design, both the native low-level assembly language (referred to as
    "basic") and a higher-level language (referred to as "interpreter")
    were supported by the system, and a Block 1 program is an
    intermixture of both of these two programming languages.<br>
    <br>
    Because each of the interpreter's instructions represented many AGC
    assembly-language instructions, a larger amount of functionality
    could be fitted into the same amount of core memory, even accounting
    for the fact that software was needed to implement the interpreter.
    The drawback was that implementing any particular functionality in
    interpretive language required far more execution time than
    implementing the same functionality directly in AGC assembly
    language. But as long as the program ran "fast enough", that didn't
    matter very much.&nbsp; Between an assembly-language block of code
    and an interpretive block of code, there will be a call (in assembly
    language) to the interpreter subroutine.&nbsp; In other words, the
    interpreter subroutine expects to find the code it is going to
    interpret following the assembly language instruction which called
    it.&nbsp; Similarly, a block of interpretive code ends with a
    specific interpreter instruction meaning "stop interpreting and jump
    to the next location in memory".<br>
    <br>
    Because of this intermixing, both assembly language and interpretive
    language have to be understood for effective programming of the
    device.<br>
    <h3><a name="Formatting"></a>Source-Code Formatting Information<br>
    </h3>
    The Virtual AGC project's AGC assembler program is known as <a
      href="yaYUL.html"><b>yaYUL</b></a>.<br>
    <br>
    The format of source code accepted by <span style="font-weight:
      bold;">yaYUL</span> differs slightly from that accepted by the
    original <span style="font-weight: bold;">YUL</span> assembler, and
    thus reflected in the assembly listings created by <b>YUL</b>. This
    is partly because without documentation for <span
      style="font-weight: bold;">YUL</span>, determining the exact
    format required by it requires more effort than I care for; but
    also, formatting restrictions based on strict column alignment—which
    make a lot of sense with punch-cards—make little sense now that
    punch-cards have gone to their final resting place.&nbsp; Thus, <b>yaYUL</b>
    accepts a format for the Block 1 source code which is <i>almost</i>
    independent of column structure.<br>
    <br>
    Here are the principles used in formatting Block 1 <span
      style="font-weight: bold;">yaYUL</span> source files, along with
    my stylistic preferences:<br>
    <ul>
      <li>A source-code file is an ASCII (text) file, consisting of a
        series of lines.<br>
      </li>
      <li>Blank lines are ignored.</li>
      <li>The character '#' is used to begin comments. Everything on a
        source line following the '#' symbol is discarded. (In the
        original <span style="font-weight: bold;">YUL</span>, the
        source code was on punch cards, with one line of code per card.
        I believe that the entire card was a comment if a certain
        non-blank character appeared in column 1. I'm not certain how
        comments at the end of a line of source code were recognized;
        they were either column-dependent, or else the parser simply
        gave up after all valid fields had been parsed. In any case, <span
          style="font-weight: bold;">yaYUL</span> does not support any
        of the original <span style="font-weight: bold;">YUL</span>'s
        specific commenting methods.)</li>
      <li>If the character '$' is encountered in column 1 of a line,
        then the line contains the name of a source file which is to be
        inserted at that point. For example, if
        "$INTERRUPT_LEAD_INS.agc" is encountered in column 1, then <span
          style="font-weight: bold;">yaYUL</span> will process all of
        the file INTERRUPT_LEAD_INS.agc before proceeding to process the
        remainder of the original source file. (The original <span
          style="font-weight: bold;">YUL</span> had no such source-code
        directive, since it did not process "files".)<br>
      </li>
      <li>Programmer-defined names (such as program labels and constants
        being defined) begin in column 1. They are 8 characters or less
        in size, and may contain any character except '#', and may not
        begin with the character '$'. (For example, "-1/(D)+A" would be
        a <span style="font-style: italic;">legal</span> constant name
        or program label.)</li>
      <li>A typical arrangement of items on a line of assembly-code
        would be this: optional program label, followed by an AGC opcode
        or interpreter instruction, followed by an operand for the
        opcode, followed by an optional comment. In some cases,
        additional option fields may appear between the operand and the
        comment. All fields are separated by whitespace, except that no
        space needs to precede the '#' delimiter for a comment.&nbsp;
        Stylistically, my preference is for the opcode or interpreter
        instruction to begin at the second tab stop, the operand (if
        any) at the third tab stop, options to the operand are separated
        by spaces, and the comment (if any) to begin at the fifth tab
        stop, assuming that tab stops are 8 characters apart.<br>
      </li>
      <li>In some cases, a line may have no program label but may have a
        field such as "-1", "+1", "+110", etc., preceding the opcode.
        These notations appear to serve merely as comments, and are
        simply ignored by <span style="font-weight: bold;">yaYUL</span>.
        These notations cannot begin in column 1, or else they would be
        taken for program labels.&nbsp; Stylistically, I prefer that
        these notations begin at the first tab stop.</li>
      <li><i>There is two column-based dependences, which must be
          observed</i>:&nbsp; <br>
      </li>
      <ol>
        <li>The assembly language operator or pseudo-op, or the first
          interpreter command on a line, <i>must</i> begin at the 17th
          column, and will not be recognized as a an operator,
          pseudo-op, or command otherwise.&nbsp; Tab stops are assumed
          by the assembler to advance by multiples of 8 columns, so the
          17th column is the one after 16 non-tab characters, or two tab
          characters, or any of the usual combinations of non-tab
          characters and tab characters you would expect.</li>
        <li>Sometimes, a '-' character appears in the 16th column, i.e.,
          the character preceding the assembly-language operator if
          there is one.&nbsp; The is a directive to <i>logically-complement</i>
          the output binary at that location, and is not recognized at
          any other column position.<br>
        </li>
      </ol>
    </ul>
    These principles are perhaps best understood by viewing actual
    source-code listings from Solarium 055.<br>
    <h3><a name="Data_Representation"></a>Data Representation </h3>
    <p>Numerical formats are identical to those for the Block 2 AGC, and
      I advise you to read <a
        href="assembly_language_manual.html#Data_Representation">the
        description of them that appears in the Block 2 discussion</a>.<br>
    </p>
    <h3><a name="Instruction_Representation"></a>Instruction
      Representation </h3>
    <h4><a name="Assembly-Language_Instructions"></a>Assembly-Language
      Instructions</h4>
    The instruction set is far smaller, and therefore far simpler, than
    in Block 2.&nbsp; Every assembly-language instruction occupies
    precisely one word of memory (including operand), and consists of 15
    bits as follows:<br>
    <br>
    <div style="margin-left: 40px;"><span style="font-family:
        monospace;">CCC AAA AAA AAA AAA<br>
      </span></div>
    <br>
    The 3-bit field <span style="font-family: monospace;">CCC</span>
    represents the instruction type (the "code"), while the 12-bits <span
      style="font-family: monospace;">AAAAAAAAAAAA</span> represent a
    memory address.&nbsp; With this simple scheme, there are at most 8
    instruction types, each of which can operate on any memory location
    within a 4096-word area of memory. <br>
    <br>
    TBD<br>
    <h3><a name="AGC4_Instruction_Set"></a>AGC4 Instruction Set <br>
    </h3>
    <h4>STORE</h4>
    <table style="text-align: left; width: 100%;" border="1"
      cellpadding="2" cellspacing="2">
      <tbody>
        <tr>
          <td style="vertical-align: top; font-weight: bold; width:
            20%;">Description:<br>
          </td>
          <td style="vertical-align: top;"><br>
          </td>
        </tr>
        <tr>
          <td style="vertical-align: top; font-weight: bold;">Syntax:<br>
          </td>
          <td style="vertical-align: top;"><span style="font-family:
              monospace;">STORE&nbsp; X<br>
            </span></td>
        </tr>
        <tr>
          <td style="vertical-align: top; font-weight: bold; width:
            20%;">Operand(s):<br>
          </td>
          <td style="vertical-align: top;"><br>
          </td>
        </tr>
        <tr>
          <td style="vertical-align: top; font-weight: bold; width:
            20%;">Timing:<br>
          </td>
          <td style="vertical-align: top;"><br>
          </td>
        </tr>
        <tr>
          <td style="vertical-align: top; font-weight: bold;">Octal:<br>
          </td>
          <td style="vertical-align: top;"><span style="font-family:
              monospace;"><br>
            </span> </td>
        </tr>
        <tr>
          <td style="vertical-align: top; font-weight: bold;">Notes:<br>
          </td>
          <td style="vertical-align: top;"><span style="font-weight:
              bold;"></span><span style="font-family: monospace;"></span><span
              style="font-weight: bold;"></span><span style="color:
              rgb(0, 153, 0);"></span><br>
          </td>
        </tr>
      </tbody>
    </table>
    <span style="font-weight: bold;"></span><span style="font-weight:
      bold;"></span><span style="font-weight: bold;"></span>
    <h3><a name="Pseudo-Operations"></a>Pseudo-Operations </h3>
    <p>The pseudo-ops are a subset of those in Block 2.&nbsp; Actually,
      <b>yaYUL</b> supports the identical pseudo-ops for Block 1 as it
      does for Block 2, but some of those pseudo-ops simply make no
      sense for Block 1 and therefore will never appear in actual
      code.&nbsp; <a
        href="assembly_language_manual.html#Pseudo-Operations">See the
        Block 2 description</a>.<br>
    </p>
    <h3><a name="Interpreter_Instruction_Set"></a>Interpreter
      Instruction Set <br>
    </h3>
    Block 1 interpreter language is superficially similar to Block 2
    interpreter language, but is actually structured quite
    differently.&nbsp; Moreover, it partakes of certain coding
    conventions not present in Block 2.&nbsp; It is also missing a
    number of interpreter commands that are present in Block 2, while it
    has a number of commands that are not present in Block 2.<br>
    <h4>Source Code and Encoding<br>
    </h4>
    Interpreter source code is structured as a series of what are
    referred to as "equations", though they are not.&nbsp; Each
    "equation" consists of a group of commands of variable length,
    followed by a group of operands of a variable length.<br>
    <br>
    There are several different forms an equation can take, and rather
    than trying to give you a rule for them, I'll just illustrate the 4
    possible forms they can take:<br>
    <blockquote><tt><i># Pattern 1:<br>
          OPERATOR<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
          OPERAND<sub>1</sub><br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; .<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; .<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; .<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
          OPERAND<sub>N<br>
            <br>
          </sub></i></tt><tt><i><tt><i># Pattern 2:<br>
            </i></tt>OPERATOR</i></tt><tt><i><sub>A</sub> &nbsp;
          OPERATOR<sub>B</sub><br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
          OPERAND<sub>1</sub><br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; .<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; .<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; .<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
          OPERAND<sub>N<br>
            <br>
          </sub></i></tt><tt><i><tt><i># Pattern 3:<br>
            </i></tt>OPERATOR</i></tt><tt><i><sub>0</sub> &nbsp; M <br>
        </i></tt><tt><i><tt><i>OPERATOR</i></tt><tt><i><sub>1A</sub>&nbsp;



















              OPERATOR<sub>1B<br>
              </sub></i></tt></i></tt><tt><i>.<br>
          .<br>
          . &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp; <br>
        </i></tt><tt><i><tt><i><tt><i><tt><i>OPERATOR</i></tt><tt><i><sub>MA</sub>&nbsp;



















                      OPERATOR<sub>MB<br>
                      </sub></i></tt></i></tt></i></tt>&nbsp;&nbsp;&nbsp;&nbsp;



















          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp; OPERAND<sub>1</sub><br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; .<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; .<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; .<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
          OPERAND<sub>N<br>
          </sub></i></tt><br>
      <tt><i><sub><br>
          </sub></i></tt><tt><i><tt><i># Pattern 4:<br>
            </i></tt>OPERATOR</i></tt><tt><i><sub>0</sub> &nbsp; M <br>
        </i></tt><tt><i><tt><i>OPERATOR</i></tt><tt><i><sub>1A</sub>&nbsp;



















              OPERATOR<sub>1B<br>
              </sub></i></tt></i></tt><tt><i>.<br>
          .<br>
          . &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp; <br>
        </i></tt><tt><i><tt><i><tt><i><tt><i>OPERATOR</i></tt><tt><i><sub>M</sub>
                      <sub><br>
                      </sub></i></tt></i></tt></i></tt>&nbsp;&nbsp;&nbsp;&nbsp;



















          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp; OPERAND<sub>1</sub><br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; .<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; .<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; .<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
          OPERAND<sub>N<br>
          </sub></i></tt> </blockquote>
    Now, each operator employs a certain number of operands, either 0 or
    1, and you would superficially expect the number of operands in the
    equation to add up to the number of operands required by the
    operators.&nbsp; However, this is seldom true, and there can be
    either more or less operands than you would expect.<br>
    <br>
    TBD<br>
    <h3><a name="Instruction-Set_Summary_Tables"></a>Instruction-Set
      Summary Tables</h3>
    <span style="font-style: italic;"></span>TBD<br>
    <br>
    <hr size="2" width="100%">
    <h2><a name="Pulse_Sequences"></a>Pulse Sequences</h2>
    <p>TBD<br>
    </p>
    <hr size="2" width="100%">
    <h2><a name="Available_Block_1_AGC_Software"></a>Available Block 1
      AGC Software</h2>
    <p>At present, the only true Block 1 software available is:<br>
    </p>
    <ul>
      <li>Solarium 055 — AGC mission software for the unmanned Apollo 6
        mission, for which we have:</li>
      <ul>
        <li><a
            href="http://www.ibiblio.org/apollo/ScansForConversion/Solarium055/">Raw














            images of the Solarium 055 assembly listing</a> once
          belonging to AGC developer Eldon C. Hall, from 1966.</li>
        <li><a
href="file:///home/rburkey/git/virtualagc-web/listings/Solarium055/MAIN.agc.html">Colorized,














            syntax-highlighted assembly listing</a>, from 2016.</li>
        <li>Source code, <a
            href="https://github.com/rburkey2005/virtualagc/tree/master/Solarium055">in














            our GitHub repository</a>.<br>
        </li>
      </ul>
    </ul>
    <p>though there are prospects for Block 1 software in the
      future.&nbsp; See also the section on <a
        href="#John_Pultoraks_Assembler_and_Simulator">John Pultorak's
        assembler and simulator</a>.<br>
    </p>
    <hr size="2" width="100%">
    <h2><a name="Available_Supporting_Software"></a>Available Supporting
      Software</h2>
    <h3><a name="Virtual_AGCs_Assembler_yaYUL"></a>Virtual AGC's
      Assembler (yaYUL)</h3>
    The Virtual AGC project itself also provides a Block 1 assembler,
    and it is <a
href="file:///media/STORAGE/home/rburkey/Desktop/sandroid.org/public_html/apollo/yaYUL.html">the














      same <b>yaYUL</b> assembler used for Block 2 code</a>.&nbsp; The
    only difference is that you add a command-line switch of --block1,
    but otherwise it operates identically, and accepts the full syntax
    of the Solarium program.<br>
    <h3><a name="CPU_Simulators"></a>CPU Simulators</h3>
    <h4><a name="Comparison"></a>Comparison</h4>
    <p>There are <i>two</i> Block 1 CPU simulators.&nbsp; Because each
      has its advantages, both are described in more detail in the
      sections dedicated to them that follow.&nbsp; However, a capsule
      comparison is given by the following table.&nbsp; <br>
    </p>
    <table align="center" border="1" cellpadding="2" cellspacing="2">
      <tbody>
        <tr>
          <th valign="top">Feature<br>
          </th>
          <th valign="top">Pultorak Simulator (yaAGC-Block1)<br>
          </th>
          <th valign="top">Virtual AGC Simulator (yaAGCb1)<br>
          </th>
        </tr>
        <tr>
          <td valign="middle"><b>Detailed information</b><b><br>
            </b> </td>
          <td valign="middle"><a
              href="#John_Pultoraks_Assembler_and_Simulator">See the
              next section</a><br>
          </td>
          <td valign="middle"><a
              href="#Virtual_AGCs_CPU_Simulator_yaAGCb1">See second
              section after this</a><br>
          </td>
        </tr>
        <tr>
          <td valign="middle"><b>Design rationale</b><b><br>
            </b> </td>
          <td valign="middle">Simulates <a href="#Pulse_Sequences">command-pulse




              sequences</a><br>
          </td>
          <td valign="middle">Simulates <a
              href="#Assembly-Language_Instructions">basic instruction
              set</a><br>
          </td>
        </tr>
        <tr>
          <td valign="middle"><b>DSKY?</b><b><br>
            </b> </td>
          <td valign="middle">Textual interface only<br>
          </td>
          <td valign="middle">Planned to operated with <a
              href="#Virtual_AGCs_DSKY_Simulator_yaDSKYb1">simulated
              DSKY</a><br>
          </td>
        </tr>
        <tr>
          <td valign="middle"><b>Other peripherals?</b><b><br>
            </b> </td>
          <td valign="middle">Text-based interface<br>
          </td>
          <td valign="middle">Planned to have a <a
              href="developer.html">yaAGC-type socket interface</a> or
            NASSP/Orbiter interface for implementation of arbitrary
            peripheral devices<br>
          </td>
        </tr>
        <tr>
          <td valign="middle"><b>Language</b><b><br>
            </b> </td>
          <td valign="middle">C++<br>
          </td>
          <td valign="middle">C<br>
          </td>
        </tr>
        <tr>
          <td valign="middle"><b>Platform/Compiler</b><b><br>
            </b> </td>
          <td valign="middle">Any platform supporting gcc or similar<br>
          </td>
          <td valign="middle">Any platform supporting gcc or similar<br>
          </td>
        </tr>
        <tr>
          <td valign="middle"><b>Written by</b><b><br>
            </b> </td>
          <td valign="middle">John Pultorak<br>
          </td>
          <td valign="middle">Ron Burkey<br>
          </td>
        </tr>
        <tr>
          <td valign="middle"><b>Purpose</b><b><br>
            </b> </td>
          <td valign="middle">Intended to support John's development of
            his hardware Block 1 simulator.<br>
          </td>
          <td valign="middle">Intended to intended to integrate into
            Virtual AGC on the same footing as Block 2 AGC and AEA
            simulators, and specifically to run <a href="Colossus.html">Solarium




              055</a>.<br>
          </td>
        </tr>
        <tr>
          <td valign="middle"><b>Status</b><b><br>
            </b></td>
          <td valign="middle">Progressing nicely, but not quite ready
            for use yet.<br>
          </td>
          <td valign="middle">Progressing nicely, but not quite as
            mature as the Pultorak simulator yet.<br>
          </td>
        </tr>
      </tbody>
    </table>
    <p>The table above refers to the version of John Pultorak's
      simulator which has been ported to gcc and corrected, rather than
      to his original code, which is also available.&nbsp; Both versions
      are discussed in the following section.<br>
    </p>
    <h4><a name="John_Pultoraks_Assembler_and_Simulator"></a>John
      Pultorak's Assembler and Simulator</h4>
    <div align="center"><i><big><big>This section concerns work in
            progress</big></big></i><br>
    </div>
    <br>
    Preliminary to his <a
href="file:///home/rburkey/git/virtualagc-web/Pultorak.html#John_Pultoraks_Block_I_AGC">construction














      project for a hardware simulation of the Block 1 AGC</a>, or even
    the existence of the Virtual AGC project at all, John Pultorak also
    developed a Block 1 AGC assembler and Block 1 AGC software CPU
    simulator as a tool in aiding his development of his hardware
    simulation.&nbsp; The assembler accepts only John's own syntax
    rather than actual Block 1 program syntax, based on manual entry and
    editing of source code (for example, I believe it does not accept
    Block 1 interpreter code), and I have nothing further to say about
    it.&nbsp; Editing a 1000-page program for use with it would be
    overwhelming, particularly when there's an alternate assembler (<b>yaYUL</b>)
    that already accepts the full syntax.&nbsp; Rather, my scope here is
    limited to the simulator.<br>
    <br>
    John's original software source code for the simulator, intended to
    be built with Microsoft Visual C++, is <a
href="http://www.ibiblio.org/apollo/Pultorak_files/PultorakAssemblerAndSimulator.zip">available














      from us</a>.&nbsp; Unfortunately, his source-code files only cover
    his simulator versions through 1.15, whereas the source code for his
    simulator 1.16 is listed in <a
      href="http://www.ibiblio.org/apollo/Pultorak_files/build_agc_7.pdf">his














      PDF description of it</a>, and can be extracted if you're patient
    enough to do so.&nbsp; I know this because I have done so, though
    unfortunately didn't think to save it for you.&nbsp; Sorry!<br>
    <br>
    Donna Polehn has also created <a
      href="https://github.com/donnaware/AGC">a kind of Visual C++
      assembler/simulator development environment</a> based on this
    code, in so far as I understand it, which you may find
    interesting.&nbsp; <br>
    <br>
    Since I don't myself use Visual C++, or even Windows if I can help
    it, John's Visual C++ source code was of no direct use to me.&nbsp;
    I have, however, taken the steps needed to port version 1.16 of
    John's simulator to GNU gcc (g++).&nbsp; Feel free to assume that
    any deficiencies in the user interface are due my porting
    effort.&nbsp; It's perhaps worth noting that my purpose in porting
    this program was primarily to use it as a comparison and sanity
    check against my own simulator, as described in the next section,
    and so my motivation in improving the program's user interface
    (assuming it needs improvement) was lacking.&nbsp; Somebody might
    find pepping it up an interesting exercise.<br>
    <br>
    Right now, you can find this ported code <a
href="https://github.com/rburkey2005/virtualagc/tree/block1/yaAGC-Block1-Pultorak">in














      our GitHub repository's "block1" branch</a>.&nbsp; I have only
    worked with it in Linux, but I expect it should probably build in
    Mac OS X or Windows (with MinGW/Msys), as long as you have g++ and
    pthreads installed.&nbsp; All you have to do is <br>
    <blockquote><tt>cd <i>DirectoryContainingTheSource</i></tt><tt><br>
      </tt><tt>make</tt><br>
    </blockquote>
    The program defaults to loading Solarium055, for which you should
    have Solarium055.bin and Solarium055.lst, or at least links to them,
    in the current directory.&nbsp; The command to run it is simply<br>
    <blockquote><tt>./yaAGC-Block1 --power</tt><br>
    </blockquote>
    at which point anything else that happens must be controlled by the
    program's internal textual interface.&nbsp; John describes using
    this command set in <a
      href="http://www.ibiblio.org/apollo/Pultorak_files/build_agc_7.pdf">his














      PDF description of the simulator</a>, though my own changes have
    forced changes in the command set as well.&nbsp; The commands I
    personally find useful (actually, the only ones I have ever used)
    are:<br>
    <ul>
      <li>m&lt;Enter&gt; — displays a menu of commands.</li>
      <li>n&lt;Enter&gt; — toggles between stepping through
        control-pulses vs stepping through basic instructions.&nbsp;
        (The default is basic instructions.)</li>
      <li>t&lt;Enter&gt; — steps one control pulse or basic instruction.</li>
      <li>v&lt;Enter&gt; — begin a free run of the program.</li>
      <li>u&lt;Enter&gt; — stops a free run of the program.<br>
      </li>
      <li>t<i>N</i>&lt;Enter&gt; — steps <i>N</i> control pulses or
        basic instructions.</li>
      <li>b<i>E</i>&lt;Enter&gt; or b<i>B,O</i>&lt;Enter&gt; — set a
        breakpoint at erasable or fixed-fixed address <i>E</i> (i.e.,
        0000-7777) or fixed address <i>B,O</i> (03,6000 through
        34,7777).&nbsp; All are octal.&nbsp; A "flat" address can also
        be used.&nbsp; Only one breakpoint can be set at any given time.<br>
      </li>
      <li>b — clear a breakpoint if one is set.</li>
      <li>e<i>N</i>&lt;Enter&gt; — inspect memory words beginning at
        (erasable, fixed-fixed, or flat, but at present not banked)
        address <i>N</i>.</li>
      <li>f&lt;Enter&gt; — toggle source-code display on/off.&nbsp;
        Default is on. </li>
      <li>q&lt;Enter&gt; — quit the program.</li>
    </ul>
    <p>There are also commands for the built-in textual DSKY, but I
      don't understand how they work.<br>
    </p>
    <p>There are also command-line options that allow you to do various
      things, such as selecting a different program than Solarium
      055.&nbsp; The program will accept rope files and program-listing
      files created either <b>yaYUL</b> (with the --block1 switch),
      assuming you had some Block 1 program other than Solarium to work
      with, or else as produced by John's own assembler.&nbsp; A <b>yaYUL</b>
      command like the following<br>
    </p>
    <blockquote><tt>yaYUL --block1 --unpound-page MAIN.agc &gt;</tt><tt><i>program</i></tt><tt>.lst<br>
        mv MAIN.agc.bin <i>program</i>.bin<br>
      </tt></blockquote>
    would produce the necessary files, which could then be run in the
    simulator as follows:<br>
    <blockquote>
      <p><tt>./yaAGC-Block1 --power --rope=<i>program</i></tt><br>
      </p>
    </blockquote>
    As far as John's own sample Block 1 program (agc.bin + agc.lst),
    which he manufactured manually from portions of Colossus 249, it
    will actually no longer run properly in this ported version of the
    simulator, even though the simulator accepts output from John's
    assembler.&nbsp; It would require the use of John's original Visual
    C++ code.<br>
    <br>
    The reason for this is that the program has not merely been ported
    from Visual C++ to gcc, but also corrected in a variety of ways, and
    these corrections prevent John's original code from running,
    although the changes needed to make is run seem fairly
    trivial.&nbsp; The <i>reason</i> that the corrections were needed
    do not reflect on John, or on anybody, but are just an unfortunate
    fact of life.&nbsp; Specifically, at the time John created his
    project, the principal (only?) written documentation he had to work
    from was <a href="#Available_Documentation">Instrumentation Labs
      document R-393</a>, which was itself inaccurate in a number of
    ways.&nbsp; As the document itself points out in its Preface,<br>
    <blockquote><small>"... Fine detail and internal consistency have
        been under-emphasized for the sake of promptness so that this
        report could be written within a few weeks of the inception of
        the design."</small><br>
    </blockquote>
    In other words, they had to get it done and get it into service
    quickly, and didn't have time fix every little thing in it.&nbsp;
    Moreover, there was no available sample of Block 1 software of any
    kind for John to work with.&nbsp; In fact, as he himself says, the
    sole sample of AGC code he had, the Block 2 program Colossus 249,
    was itself not complete, and was merely a fragment.&nbsp; So all
    things considered, it is remarkable that he got any of it to work at
    all, and the fact that there are some errors is inevitable.&nbsp;
    But those errors are more than enough to prevent John's original
    code from running on a corrected version of his simulator.<br>
    <br>
    The reason I am pointing this out is to provide you with a warning,
    should you decide to forego the corrected, gcc version of the
    program, and instead revert to John's original Visual C++
    simulator.&nbsp; None of the corrections for the problems I've been
    mentioning have been back-ported to the Visual C++ version of the
    program.&nbsp; It might be an interesting exercise for somebody to
    indeed backport these changes.&nbsp; The most-significant problems
    were:<br>
    <ol>
      <li>The memory model is undersized:&nbsp; the amount of fixed rope
        memory in the device was increased from the 12 banks mentioned
        in R-393 to 24 banks, and Solarium 055 will in fact not fit into
        12 banks.</li>
      <li>The (corrected) interrupt-vector table is at address 2000, and
        the entry point for the program is at 2030.&nbsp; In the
        original version of the program, however, they are at 2004 and
        2000, respectively.</li>
      <li>Certain assembly-language instructions for writing to the
        memory-bank register (specifically, the XCH instruction)
        produced completely incorrect results.</li>
      <li>Instructions for writing to some of the "editing" registers
        (CYL, SL, CYR, SR) produced partially incorrect results.<br>
      </li>
    </ol>
    <ul>
    </ul>
    A remarkably short list of problems, but nevertheless a list in
    which one would encounter difficulties <i>immediately</i> in trying
    to run actual Block 1 software ... as indeed I did.&nbsp; <br>
    <font face="Calibri" color="blue" size="3"><span style="font-size:
        12.0pt;font-family:Calibri;color:blue"><font color="#000000"></font></span></font>
    <ul>
    </ul>
    <ul>
    </ul>
    <h4><a name="Virtual_AGCs_CPU_Simulator_yaAGCb1"></a>Virtual AGC's
      CPU Simulator (yaAGCb1) TBD</h4>
    <p align="center"><i><big><big>This section concerns work in
            progress</big></big></i></p>
    <p>My own Block 1 simulator is written independently of <a
        href="#John_Pultoraks_Assembler_and_Simulator">John Pultorak's</a>,
      and no code from John's has been reused in mine, nor served as a
      model for mine.&nbsp; That isn't intended to imply that John's
      program was not used.&nbsp; In fact, I used it <i>extensively</i>
      as a cross-check on the functioning of mine, with the intention of
      being able to run the two side-by-side, and have them match up
      register-for-register, instruction-for-instruction, on a
      cycle-by-cycle basis.&nbsp; Sometimes this revealed errors in
      John's simulator, which I corrected.&nbsp; Other times, it
      revealed bugs in mine, which I corrected.&nbsp; Often, there were
      just differences I hadn't anticipated, usually involving
      arithmetical overflow bits that got written into registers I
      hadn't expected; in which case, when they were reasonable even if
      unexpected, I did what checking I could but almost always adopted
      John's approach in place of my own.<br>
    </p>
    <p>So the upshot of that is that these programs now behave
      essentially identically.<br>
    </p>
    <p>Then why have two (other than the obvious advantage of being able
      to cross-check one against the other)?&nbsp; Well, it mainly has
      to do with the fact that the CPU simulator has to be able to
      integrate with other Virtual-AGC style peripheral devices, such as
      simulated DSKYs, to be able to participate in the GUI code::blocks
      style debugging capabilities that other Virtual AGC simulators
      have, and so on, and after investigating it I just thought it was
      cleaner and simpler to start from scratch in doing so.&nbsp;
      Obviously, others' opinions may differ, and the problems I
      perceived I was solving could easily be more in my mind than in
      John's program.<br>
    </p>
    <p>Right now, you can find code for my new simulator <a
        href="https://github.com/rburkey2005/virtualagc/tree/block1/yaAGCb1">in














        our GitHub repository's "block1" branch</a>.&nbsp; I have only
      worked with it in Linux, but I expect it should probably build in
      Mac OS X or Windows (with MinGW/Msys), as long as you have g++ and
      pthreads installed.&nbsp; All you have to do is <br>
    </p>
    <blockquote><tt>cd <i>DirectoryContainingTheSource</i></tt><tt><br>
      </tt><tt>make</tt><br>
    </blockquote>
    The program defaults to loading Solarium055, for which you should
    have Solarium055.bin and Solarium055.lst, or at least links to them,
    in the current directory.&nbsp; The command to run it is simply<br>
    <blockquote><tt>./yaAGCb1</tt><br>
    </blockquote>
    at which point anything else that happens must be controlled by the
    program's internal textual interface, because at this writing,
    neither <a href="Block1.html#Virtual_AGCs_DSKY_Simulator_yaDSKYb1">the


      simulated DSKY interface</a> nor the fancy GUI debugging mentioned
    above have actually been implemented yet.&nbsp; The program textual
    debugging interface is indeed <i>extremely</i> primitive, a small
    subset of the interface to the Pultorak simulator's interface
    mentioned in the preceding section.&nbsp; The only existing commands
    at the moment are:<br>
    <ul>
      <li>m&lt;Enter&gt; (or actually any unrecognized command) —
        displays a menu of available commands.<br>
      </li>
      <li>t&lt;Enter&gt; — steps one control pulse or basic instruction.</li>
      <li>t<i>N</i>&lt;Enter&gt; — steps <i>N</i> control pulses or
        basic instructions.</li>
      <li>q&lt;Enter&gt; — quit the program.</li>
    </ul>
    One useful capability that both of the CPU simulators (Pultorak and
    Virtual AGC) have is to be able to produce a log file <i>in
      identical formats</i> of the cycle-by-cycle program
    execution.&nbsp; This allows easy comparison for discrepancies with
    programs like diff or <a href="http://meldmerge.org/">meld</a>, or
    any of a number of others.&nbsp; The steps in either simulator are
    the same:<br>
    <ol>
      <li>Run the simulator with a command-line switch "--log=<i>FILENAME</i>".</li>
      <li>Execute identical portions of the code in the simulator, for
        example with "t2000" to execute 2000 assembly-language
        instructions.</li>
      <li>Quit the simulator ("q").<br>
      </li>
    </ol>
    <h3><a name="Virtual_AGCs_DSKY_Simulator_yaDSKYb1"></a>Virtual AGC's
      DSKY Simulator (yaDSKYb1)</h3>
    <div align="center"><i><big><big>This section concerns work in
            progress</big></big></i><br>
    </div>
    <br>
    TBD<br>
    <br>
    <hr style="width: 100%; height: 2px;"><br>
    <center><i><font size="-1">Last modified by <a
            href="mailto:info@sandroid.org">Ronald Burkey</a> on
          2016-09-06.<br>
          <br>
          <a href="http://www.ibiblio.org"><img style="border: 0px solid
              ; width: 300px; height: 100px;" alt="Virtual AGC is hosted
              by ibiblio.org" src="hosted.png" height="100" width="300"></a><br>
        </font></i></center>
    <br>
  </body>
</html>
